#!/usr/bin/env python3
"""
Simple Pentest MCP Server - Security testing tools for educational purposes in controlled environments
"""
import os
import sys
import logging
import subprocess
import re
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("pentest-server")

# Initialize MCP server
mcp = FastMCP("pentest")

# Configuration
MAX_OUTPUT_LINES = 100

# === UTILITY FUNCTIONS ===

def sanitize_target(target: str) -> str:
    """Sanitize and validate target input to prevent command injection."""
    target = target.strip()
    # Basic validation - alphanumeric, dots, dashes, slashes for URLs/IPs
    if not re.match(r'^[a-zA-Z0-9\.\-\_\:\/]+$', target):
        raise ValueError("Invalid target format. Use only alphanumeric characters, dots, dashes, underscores, colons, and slashes.")
    return target

def run_command(command: list, timeout: int = 60) -> str:
    """Execute a command safely and return formatted output."""
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        output = result.stdout if result.stdout else result.stderr
        
        # Truncate output if too long
        lines = output.split('\n')
        if len(lines) > MAX_OUTPUT_LINES:
            output = '\n'.join(lines[:MAX_OUTPUT_LINES]) + f"\n\n... (truncated {len(lines) - MAX_OUTPUT_LINES} lines)"
        
        if result.returncode == 0:
            return f"✅ Command completed successfully\n\n{output}"
        else:
            return f"⚠️ Command completed with warnings\n\n{output}"
            
    except subprocess.TimeoutExpired:
        return f"⏱️ Command timed out after {timeout} seconds"
    except Exception as e:
        logger.error(f"Command execution error: {e}")
        return f"❌ Error executing command: {str(e)}"

# === MCP TOOLS ===

@mcp.tool()
async def nmap_scan(target: str = "", scan_type: str = "quick") -> str:
    """Scan target with nmap using quick, full, or custom scan types for network discovery."""
    logger.info(f"Executing nmap_scan on {target}")
    
    if not target.strip():
        return "❌ Error: Target is required (IP address or hostname)"
    
    try:
        target = sanitize_target(target)
        
        # Define scan types
        scan_options = {
            "quick": ["-T4", "-F"],
            "full": ["-T4", "-A", "-v"],
            "stealth": ["-sS", "-T2"],
            "ping": ["-sn"]
        }
        
        options = scan_options.get(scan_type.lower(), ["-T4", "-F"])
        command = ["nmap"] + options + [target]
        
        return run_command(command, timeout=120)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"nmap error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80") -> str:
    """Scan web server with nikto for vulnerabilities and misconfigurations."""
    logger.info(f"Executing nikto_scan on {target}:{port}")
    
    if not target.strip():
        return "❌ Error: Target URL or IP is required"
    
    try:
        target = sanitize_target(target)
        port_val = port.strip() if port.strip() else "80"
        
        if not port_val.isdigit():
            return "❌ Error: Port must be a number"
        
        command = ["nikto", "-h", target, "-p", port_val, "-Tuning", "x"]
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"nikto error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def sqlmap_test(url: str = "", parameter: str = "") -> str:
    """Test URL parameter for SQL injection vulnerabilities using sqlmap."""
    logger.info(f"Executing sqlmap_test on {url}")
    
    if not url.strip():
        return "❌ Error: URL is required"
    
    try:
        url = sanitize_target(url)
        
        command = ["sqlmap", "-u", url, "--batch", "--risk=1", "--level=1"]
        
        if parameter.strip():
            command.extend(["-p", parameter.strip()])
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"sqlmap error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def wpscan_scan(url: str = "", enumerate: str = "p") -> str:
    """Scan WordPress site with wpscan for vulnerabilities, plugins (p), themes (t), or users (u)."""
    logger.info(f"Executing wpscan_scan on {url}")
    
    if not url.strip():
        return "❌ Error: WordPress URL is required"
    
    try:
        url = sanitize_target(url)
        enum_option = enumerate.strip() if enumerate.strip() else "p"
        
        command = ["wpscan", "--url", url, "--enumerate", enum_option, "--no-banner"]
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"wpscan error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def dirb_scan(url: str = "", wordlist: str = "common") -> str:
    """Scan website for hidden directories and files using dirb with common or big wordlists."""
    logger.info(f"Executing dirb_scan on {url}")
    
    if not url.strip():
        return "❌ Error: URL is required"
    
    try:
        url = sanitize_target(url)
        
        # Select wordlist
        wordlists = {
            "common": "/usr/share/dirb/wordlists/common.txt",
            "big": "/usr/share/dirb/wordlists/big.txt"
        }
        
        wordlist_path = wordlists.get(wordlist.lower(), wordlists["common"])
        
        command = ["dirb", url, wordlist_path, "-S"]
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"dirb error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def searchsploit_search(query: str = "") -> str:
    """Search exploitdb database for exploits matching the query term."""
    logger.info(f"Executing searchsploit_search for {query}")
    
    if not query.strip():
        return "❌ Error: Search query is required"
    
    try:
        # Allow more characters for search queries
        query = query.strip()
        
        command = ["searchsploit", query]
        
        return run_command(command, timeout=30)
        
    except Exception as e:
        logger.error(f"searchsploit error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def ping_test(target: str = "", count: str = "4") -> str:
    """Ping target to test connectivity with specified packet count."""
    logger.info(f"Executing ping_test on {target}")
    
    if not target.strip():
        return "❌ Error: Target is required"
    
    try:
        target = sanitize_target(target)
        count_val = count.strip() if count.strip() else "4"
        
        if not count_val.isdigit():
            return "❌ Error: Count must be a number"
        
        command = ["ping", "-c", count_val, target]
        
        return run_command(command, timeout=30)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"ping error: {e}")
        return f"❌ Error: {str(e)}"

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting Pentest MCP server...")
    logger.info("⚠️  WARNING: This server is for EDUCATIONAL USE ONLY in controlled environments")
    logger.info("⚠️  Only scan systems you own or have explicit permission to test")
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)