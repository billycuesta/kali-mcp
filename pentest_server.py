#!/usr/bin/env python3
"""
Simple Pentest MCP Server - Security testing tools for educational purposes in controlled environments
"""
import os
import sys
import logging
import subprocess
import re
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("pentest-server")

# Initialize MCP server
mcp = FastMCP("pentest")

# Configuration
MAX_OUTPUT_LINES = 100

# === UTILITY FUNCTIONS ===

def sanitize_target(target: str) -> str:
    """Sanitize and validate target input to prevent command injection."""
    target = target.strip()
    # Basic validation - alphanumeric, dots, dashes, slashes for URLs/IPs
    if not re.match(r'^[a-zA-Z0-9\.\-\_\:\/]+$', target):
        raise ValueError("Invalid target format. Use only alphanumeric characters, dots, dashes, underscores, colons, and slashes.")
    return target

def run_command(command: list, timeout: int = 60) -> str:
    """Execute a command safely and return formatted output."""
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        output = result.stdout if result.stdout else result.stderr
        
        # Truncate output if too long
        lines = output.split('\n')
        if len(lines) > MAX_OUTPUT_LINES:
            output = '\n'.join(lines[:MAX_OUTPUT_LINES]) + f"\n\n... (truncated {len(lines) - MAX_OUTPUT_LINES} lines)"
        
        if result.returncode == 0:
            return f"✅ Command completed successfully\n\n{output}"
        else:
            return f"⚠️ Command completed with warnings\n\n{output}"
            
    except subprocess.TimeoutExpired:
        return f"⏱️ Command timed out after {timeout} seconds"
    except Exception as e:
        logger.error(f"Command execution error: {e}")
        return f"❌ Error executing command: {str(e)}"

# === MCP TOOLS ===

@mcp.tool()
async def nmap_scan(target: str = "", scan_type: str = "quick") -> str:
    """Scan target with nmap using quick, full, or custom scan types for network discovery."""
    logger.info(f"Executing nmap_scan on {target}")
    
    if not target.strip():
        return "❌ Error: Target is required (IP address or hostname)"
    
    try:
        target = sanitize_target(target)
        
        # Define scan types
        scan_options = {
            "quick": ["-T4", "-F"],
            "full": ["-T4", "-A", "-v"],
            "stealth": ["-sS", "-T2"],
            "ping": ["-sn"]
        }
        
        options = scan_options.get(scan_type.lower(), ["-T4", "-F"])
        command = ["nmap"] + options + [target]
        
        return run_command(command, timeout=120)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"nmap error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80") -> str:
    """Scan web server with nikto for vulnerabilities and misconfigurations."""
    logger.info(f"Executing nikto_scan on {target}:{port}")
    
    if not target.strip():
        return "❌ Error: Target URL or IP is required"
    
    try:
        target = sanitize_target(target)
        port_val = port.strip() if port.strip() else "80"
        
        if not port_val.isdigit():
            return "❌ Error: Port must be a number"
        
        command = ["nikto", "-h", target, "-p", port_val, "-Tuning", "x"]
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"nikto error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def sqlmap_test(url: str = "", parameter: str = "") -> str:
    """Test URL parameter for SQL injection vulnerabilities using sqlmap."""
    logger.info(f"Executing sqlmap_test on {url}")
    
    if not url.strip():
        return "❌ Error: URL is required"
    
    try:
        url = sanitize_target(url)
        
        command = ["sqlmap", "-u", url, "--batch", "--risk=1", "--level=1"]
        
        if parameter.strip():
            command.extend(["-p", parameter.strip()])
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"sqlmap error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def wpscan_scan(url: str = "", enumerate: str = "p") -> str:
    """Scan WordPress site with wpscan for vulnerabilities, plugins (p), themes (t), or users (u)."""
    logger.info(f"Executing wpscan_scan on {url}")
    
    if not url.strip():
        return "❌ Error: WordPress URL is required"
    
    try:
        url = sanitize_target(url)
        enum_option = enumerate.strip() if enumerate.strip() else "p"
        
        command = ["wpscan", "--url", url, "--enumerate", enum_option, "--no-banner"]
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"wpscan error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def dirb_scan(url: str = "", wordlist: str = "common") -> str:
    """Scan website for hidden directories and files using dirb with common or big wordlists."""
    logger.info(f"Executing dirb_scan on {url}")
    
    if not url.strip():
        return "❌ Error: URL is required"
    
    try:
        url = sanitize_target(url)
        
        # Select wordlist
        wordlists = {
            "common": "/usr/share/dirb/wordlists/common.txt",
            "big": "/usr/share/dirb/wordlists/big.txt"
        }
        
        wordlist_path = wordlists.get(wordlist.lower(), wordlists["common"])
        
        command = ["dirb", url, wordlist_path, "-S"]
        
        return run_command(command, timeout=180)
        
    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"dirb error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def searchsploit_search(query: str = "") -> str:
    """Search exploitdb database for exploits matching the query term."""
    logger.info(f"Executing searchsploit_search for {query}")
    
    if not query.strip():
        return "❌ Error: Search query is required"
    
    try:
        # Allow more characters for search queries
        query = query.strip()
        
        command = ["searchsploit", query]
        
        return run_command(command, timeout=30)
        
    except Exception as e:
        logger.error(f"searchsploit error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def ping_test(target: str = "", count: str = "4") -> str:
    """Ping target to test connectivity with specified packet count."""
    logger.info(f"Executing ping_test on {target}")

    if not target.strip():
        return "❌ Error: Target is required"

    try:
        target = sanitize_target(target)
        count_val = count.strip() if count.strip() else "4"

        if not count_val.isdigit():
            return "❌ Error: Count must be a number"

        command = ["ping", "-c", count_val, target]

        return run_command(command, timeout=30)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"ping error: {e}")
        return f"❌ Error: {str(e)}"

# === AWS SECURITY TOOLS ===

@mcp.tool()
async def prowler_scan(profile: str = "default", regions: str = "us-east-1") -> str:
    """Run Prowler for AWS security assessment with specified profile and regions."""
    logger.info(f"Executing Prowler scan with profile {profile}")

    try:
        command = ["prowler", "-p", profile, "-r", regions]
        return run_command(command, timeout=300)

    except Exception as e:
        logger.error(f"Prowler error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def cloudfox_aws(profile: str = "default", operation: str = "all") -> str:
    """Run CloudFox for AWS cloud intelligence gathering (all, buckets, instances, iam, etc)."""
    logger.info(f"Executing CloudFox with profile {profile}, operation {operation}")

    try:
        command = ["cloudfox", "-v", "-p", profile, operation]
        return run_command(command, timeout=300)

    except Exception as e:
        logger.error(f"CloudFox error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def pacu_scan(command_name: str = "whoami") -> str:
    """Run PACU for AWS exploitation and assessment."""
    logger.info(f"Executing PACU command: {command_name}")

    try:
        # Note: PACU needs interactive shell, this runs specific commands
        command = ["python3", "-m", "pacu", command_name]
        return run_command(command, timeout=120)

    except Exception as e:
        logger.error(f"PACU error: {e}")
        return f"❌ Error: {str(e)}"

# === INTERNAL NETWORK TOOLS ===

@mcp.tool()
async def crackmapexec_spray(protocol: str = "smb", targets: str = "", username: str = "", password: str = "") -> str:
    """Run CME for SMB/LDAP credential spraying and enumeration."""
    logger.info(f"Executing CME with protocol {protocol}")

    if not targets.strip():
        return "❌ Error: Targets required (IP/range)"

    try:
        targets = sanitize_target(targets)
        command = ["cme", protocol, targets]

        if username.strip():
            command.extend(["-u", username.strip()])
        if password.strip():
            command.extend(["-p", password.strip()])

        return run_command(command, timeout=180)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"CME error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def enum4linux_scan(target: str = "", user: str = "", password: str = "") -> str:
    """Enumerate SMB/LDAP using enum4linux."""
    logger.info(f"Executing enum4linux on {target}")

    if not target.strip():
        return "❌ Error: Target is required"

    try:
        target = sanitize_target(target)
        command = ["enum4linux", "-a", target]

        if user.strip() and password.strip():
            command.extend(["-u", user.strip(), "-p", password.strip()])

        return run_command(command, timeout=180)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"enum4linux error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def responder_listen(interface: str = "eth0", duration: str = "60") -> str:
    """Start Responder to capture LLMNR/NBT-NS traffic (internal network only)."""
    logger.info(f"Starting Responder on {interface} for {duration}s")

    try:
        dur = int(duration) if duration.strip().isdigit() else 60
        command = ["responder", "-I", interface, "-dw", "-t", str(dur)]

        return run_command(command, timeout=int(duration) + 30)

    except ValueError:
        return "❌ Error: Duration must be a number"
    except Exception as e:
        logger.error(f"Responder error: {e}")
        return f"❌ Error: {str(e)}"

# === PASSWORD CRACKING TOOLS ===

@mcp.tool()
async def hashcat_crack(hashfile: str = "", hashtype: str = "0", wordlist: str = "/usr/share/wordlists/rockyou.txt") -> str:
    """Crack hashes using hashcat (hashtype: 0=MD5, 1=MD5 Unix, 3=MD5+salt, etc)."""
    logger.info(f"Cracking hashes with hashcat")

    if not hashfile.strip():
        return "❌ Error: Hash file path required"

    try:
        command = ["hashcat", "-m", hashtype.strip(), hashfile.strip(), wordlist.strip()]
        return run_command(command, timeout=300)

    except Exception as e:
        logger.error(f"hashcat error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def john_crack(hashfile: str = "", format_type: str = "auto") -> str:
    """Crack password hashes using John the Ripper."""
    logger.info(f"Cracking with John the Ripper")

    if not hashfile.strip():
        return "❌ Error: Hash file path required"

    try:
        command = ["john", "--format=" + format_type.strip(), hashfile.strip()]
        return run_command(command, timeout=300)

    except Exception as e:
        logger.error(f"John error: {e}")
        return f"❌ Error: {str(e)}"

# === WEB SCANNING & FUZZING ===

@mcp.tool()
async def nuclei_scan(url: str = "", templates: str = "cves") -> str:
    """Scan with Nuclei using template-based detection."""
    logger.info(f"Running Nuclei on {url}")

    if not url.strip():
        return "❌ Error: URL required"

    try:
        url = sanitize_target(url)
        command = ["nuclei", "-u", url, "-t", templates.strip()]
        return run_command(command, timeout=180)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"Nuclei error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def feroxbuster_scan(url: str = "", wordlist: str = "") -> str:
    """Fast directory brute-force using Feroxbuster."""
    logger.info(f"Running Feroxbuster on {url}")

    if not url.strip():
        return "❌ Error: URL required"

    try:
        url = sanitize_target(url)
        command = ["feroxbuster", "-u", url, "-w", wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/dirb/common.txt"]
        return run_command(command, timeout=180)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"Feroxbuster error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def ffuf_fuzz(url: str = "", wordlist: str = "", keyword: str = "FUZZ") -> str:
    """Parameter fuzzing with ffuf."""
    logger.info(f"Running ffuf on {url}")

    if not url.strip():
        return "❌ Error: URL required"

    try:
        url = sanitize_target(url)
        wl = wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/dirb/common.txt"
        command = ["ffuf", "-u", url, "-w", wl, "-c"]
        return run_command(command, timeout=180)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"ffuf error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def wafw00f_detect(url: str = "") -> str:
    """Detect WAF/IPS/IDS protection."""
    logger.info(f"Running wafw00f on {url}")

    if not url.strip():
        return "❌ Error: URL required"

    try:
        url = sanitize_target(url)
        command = ["wafw00f", url]
        return run_command(command, timeout=60)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"wafw00f error: {e}")
        return f"❌ Error: {str(e)}"

@mcp.tool()
async def gobuster_fuzz(url: str = "", wordlist: str = "", mode: str = "dir") -> str:
    """Web fuzzing with Gobuster (dir/dns/vhost modes)."""
    logger.info(f"Running Gobuster on {url}")

    if not url.strip():
        return "❌ Error: URL required"

    try:
        url = sanitize_target(url)
        wl = wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/dirb/common.txt"
        command = ["gobuster", mode.strip(), "-u", url, "-w", wl, "-q"]
        return run_command(command, timeout=180)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"Gobuster error: {e}")
        return f"❌ Error: {str(e)}"

# === SSL/TLS ANALYSIS ===

@mcp.tool()
async def testssl_check(target: str = "") -> str:
    """Deep SSL/TLS analysis using testssl.sh."""
    logger.info(f"Running testssl.sh on {target}")

    if not target.strip():
        return "❌ Error: Target required"

    try:
        target = sanitize_target(target)
        command = ["/usr/bin/testssl.sh", "--json", target]
        return run_command(command, timeout=300)

    except ValueError as e:
        return f"❌ Error: {str(e)}"
    except Exception as e:
        logger.error(f"testssl.sh error: {e}")
        return f"❌ Error: {str(e)}"

# === AWS CLI DIRECT ACCESS ===

@mcp.tool()
async def aws_cli_command(command: str = "", profile: str = "default") -> str:
    """Execute AWS CLI commands directly (buckets, instances, iam, etc)."""
    logger.info(f"Running AWS CLI: {command}")

    if not command.strip():
        return "❌ Error: Command required"

    try:
        # Build command safely
        cmd_parts = command.strip().split()
        full_command = ["aws"] + cmd_parts + ["--profile", profile.strip()]
        return run_command(full_command, timeout=60)

    except Exception as e:
        logger.error(f"AWS CLI error: {e}")
        return f"❌ Error: {str(e)}"

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting Pentest MCP server...")
    logger.info("⚠️  WARNING: This server is for EDUCATIONAL USE ONLY in controlled environments")
    logger.info("⚠️  Only scan systems you own or have explicit permission to test")
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)